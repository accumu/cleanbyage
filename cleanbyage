#!/usr/local/bin/perl -w
# vim:ts=4:sw=4:et:
#
# $Id: cleanbyage,v 1.4 2006/07/18 14:29:23 root Exp $
#
# Edit on nixon.

use Filesys::Statvfs;
use Sys::Hostname;
use File::Find ();
use Getopt::Std;
use Fcntl ':mode';

use strict;
use warnings;

# Set the variable $File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

sub wanted;
sub debug;
sub printsize;

my(%opts);

# Min free percentage
my $defminfree = 20;
my $minfree = $defminfree;
my $mincleanfree = $defminfree;
my $minifree = $defminfree;
my $defexclude = "lost\+found/.*";
my $exclude = $defexclude;

getopts('hsdm:M:i:e:D', \%opts);
if(defined($opts{m})) {
    $minfree = $opts{m};
}
if(defined($opts{M})) {
    $mincleanfree = $opts{M};
}
if(defined($opts{i})) {
    $minifree = $opts{i};
}

if($minfree < 0 || $minfree > 100) {
    die "Bad value for -m: $minfree\n";
}
if($mincleanfree < 0 || $mincleanfree > 100) {
    die "Bad value for -M: $mincleanfree\n";
}
if($mincleanfree < $minfree) {
    die "-M can't be smaller than -m (now $mincleanfree/$minfree)\n"
}
if($minifree < 0 || $minifree > 100) {
    die "Bad value for -i: $minifree\n";
}

my $filesystem=shift @ARGV;

if(defined($opts{'h'}) || !defined($filesystem)) {
    print <<EOH;
   usage: $0 [flags] directory
        -h      - This help
        -s      - Statistics mode, show fs usage stats, don't delete anything
        -d      - Don't delete directories
        -m NN   - Min free space to start cleaning (percent) (default $defminfree)
        -M NN   - Free space to stop cleaning (percent) (default $defminfree)
        -i NN   - Min free inodes (percent) (default $defminfree)
        -e RE   - Exclude RE (default $defexclude)
        -D      - Debug output
EOH
    exit 1;
}

$filesystem =~ s|/+$||;

if($filesystem eq "" || ! -d $filesystem) {
    die "Not a directory: $filesystem";
}

if($opts{'e'}) {
    $exclude = $opts{'e'};
    eval {
        "kaka" =~ m|$filesystem/$exclude|;
    };
    if($@) {
        die "Bad value for -e:\n",$@,"\n";
    }
}

my($bsize, $frsize, $blocks, $bfree, $bavail, $files, $ffree, $favail,
    $fsid, $basetype, $flag, $namemax, $fstr) = statvfs($filesystem);

if(!defined($bsize)) {
    print "Unable to statvfs $filesystem: $!\n";
    exit 1;
}

my $fssize = $frsize * $blocks;
my $fsfree = $frsize * $bavail;

my $minfinode=$files*$minifree/100;
my $minfbytes=$fssize*$minfree/100;

debug "$filesystem:\nBytes\t\tInodes\n$fsfree\t$favail";

exit 0 if $fsfree > $minfbytes && $favail > $minfinode && !$opts{'s'};

$minfbytes=$fssize*$mincleanfree/100;

my %files;
my $totsize = 0; # Total size, by adding all filesizes in wanted().

File::Find::find({wanted => \&wanted}, $filesystem);

if($opts{'s'}) {
    print "Usage statistics: $filesystem\n";
    print "Total size of files found: ",printsize($totsize),"\n";
    my $increment = $totsize / 10;
    if($increment < 1) {
        print "Total size too small to do anything useful\n";
        exit 0;
    }

    printf "%-21s %-25s %s\n", "At size (% of total)", "Newest file", "Oldest file";

    my $nextinc = $increment;
    my $accumulated = 0;
    my ($newatime, $lastatime);

    foreach my $fil (sort { $files{$b}{atime} <=> $files{$a}{atime} } 
        keys %files) 
    {
        $accumulated += $files{$fil}{size};
        if(!$newatime) {
            $newatime = $files{$fil}{atime};
        }

        if($accumulated > $nextinc) {
            printf "%-21s %-25s %s\n", 
                  printsize($accumulated)." (".int(($accumulated/$totsize)*100)."%)",
                  scalar localtime($newatime),
                  scalar localtime($files{$fil}{atime});
            while($nextinc < $accumulated) {
                $nextinc += $increment;
            }
            $newatime = undef;
            $lastatime = undef;
        }
        else {
            $lastatime = $files{$fil}{atime};
        }
    }
    printf "%-21s %-25s %s\n", 
          printsize($accumulated)." (100%)", "-",
          scalar localtime($lastatime) if($lastatime);

    exit 0;
}

my @rootfiles;

foreach my $fil (sort { $files{$a}{atime} <=> $files{$b}{atime} } keys %files) {
    debug "fil: $fil  atime: $files{$fil}{atime}  size: $files{$fil}{size}";
    last if $fsfree > $minfbytes && $favail > $minfinode;

    if( $files{$fil}{uid}==0 || $files{$fil}{gid}==0 ) {
        push @rootfiles, $fil;
        next;
    }
    if($files{$fil}{mode} & S_IFDIR) {
        if ( rmdir $fil ) {
            $favail++;
            $fsfree+=$files{$fil}{size};
            debug "rmdir '$fil'";
        }
    }
    else {
        if ( unlink $fil ) {
            $favail++;
            $fsfree+=$files{$fil}{size};
            debug "unlink '$fil'";
        } else {
            print STDERR "unlink '$fil': $!\n";
        }
    }
}

if( @rootfiles ) {
    print "Root owns files marked for removal on ".hostname.":$filesystem\n";
    print join "\t\n", @rootfiles;
    print "\n";
}

exit 0;

sub wanted {
    my ($mode, $uid, $gid, $atime, $blocks);

    ($mode, $uid, $gid, $atime, $blocks) = (lstat($_))[2,4,5,8,12];
    return unless defined $uid;
    return if $name eq $filesystem;
    return if $name =~ m|$filesystem/$exclude|;

    return unless (!$opts{'d'} && -d _) || -f _ || -l _;

    $files{$name}{mode}=$mode;
    $files{$name}{uid}=$uid;
    $files{$name}{gid}=$gid;
    $files{$name}{atime}=$atime;
    $files{$name}{size}=$blocks * 512;
    $totsize += $files{$name}{size};
}

sub debug
{
    if( !defined($opts{'D'})) {
        return;
    }

    my (@args) = @_;

    print @args, "\n";
}

sub printsize($)
{
    my $size = shift;

    if($size > 1024*1024*1024*1024) {
        $size = int($size/(1024*1024*1024*1024));
        return "$size TB";
    }
    if($size > 1024*1024*1024) {
        $size = int($size/(1024*1024*1024));
        return "$size GB";
    }
    if($size > 1024*1024) {
        $size = int($size/(1024*1024));
        return "$size MB";
    }
    if($size > 1024) {
        $size = int($size/1024);
        return "$size kB";
    }

    return $size;
}
